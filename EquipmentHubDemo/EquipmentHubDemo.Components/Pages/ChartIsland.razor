@rendermode InteractiveWebAssembly
@namespace EquipmentHubDemo.Components.Pages
@using Microsoft.AspNetCore.Components.Web
@using System
@using System.Collections.ObjectModel
@using System.Threading
@using LiveChartsCore
@using LiveChartsCore.Defaults
@using LiveChartsCore.SkiaSharpView
@using LiveChartsCore.SkiaSharpView.Blazor

<p class="text-muted small">island points: @Points.Count</p>

@if (ShouldRenderChart)
{
    <CartesianChart Series="Series"
                    XAxes="xAxes"
                    YAxes="yAxes" />
}
else
{
    <div data-testid="chart-placeholder" class="alert alert-info">
        Chart rendering is available in a WebAssembly-enabled environment only.
    </div>
}

@code {
    [Parameter] public IReadOnlyList<PointDto> Points { get; set; } = Array.Empty<PointDto>();
    /// <summary>
    /// Forces the component to render the chart even when <see cref="OperatingSystem.IsBrowser"/> returns <c>false</c>.
    /// Enable this when running the UI in a WebAssembly context but the runtime cannot yet detect the browser (e.g., during
    /// prerendering) to suppress the informational placeholder.
    /// </summary>
    [Parameter]
    public bool ForceEnableChartRendering { get; set; }
    [Parameter] public string? Title { get; set; }

    private static int _configuredFlag;

    private readonly ObservableCollection<ObservablePoint> _values = new();
    private readonly Axis[] xAxes = { new Axis { Name = "Time", Labeler = v => DateTime.FromOADate(v).ToString("HH:mm:ss") } };
    private readonly Axis[] yAxes = { new Axis { Name = "Value" } };
    private ISeries[] Series = Array.Empty<ISeries>();

    private string? _lastKeyOrTitle;
    private int _lastAppliedCount;
    private long _lastObservedFirstTick;

    private bool ShouldRenderChart => ForceEnableChartRendering || OperatingSystem.IsBrowser();

    protected override void OnInitialized()
    {
        if (Interlocked.Exchange(ref _configuredFlag, 1) == 0)
        {
            LiveCharts.Configure(cfg => cfg.AddSkiaSharp()); // must happen in WASM context
        }

        Series = new ISeries[]
        {
            new LineSeries<ObservablePoint>
            {
                Values = _values,
                GeometryFill = null,
                GeometryStroke = null,
                LineSmoothness = 0
            }
        };
    }

    protected override void OnParametersSet()
    {
        if (Points is null)
        {
            throw new ArgumentNullException(nameof(Points));
        }

        for (var i = 0; i < Points.Count; i++)
        {
            if (Points[i] is null)
            {
                throw new ArgumentException("Points cannot contain null entries.", nameof(Points));
            }
        }

        var requiresFullSync = false;

        if (_lastKeyOrTitle != Title)
        {
            requiresFullSync = true;
        }

        var currentCount = Points.Count;

        if (!requiresFullSync && currentCount < _lastAppliedCount)
        {
            requiresFullSync = true;
        }

        if (!requiresFullSync && _values.Count != currentCount)
        {
            requiresFullSync = true;
        }

        if (!requiresFullSync && currentCount > 0)
        {
            var firstTick = Points[0].X.Ticks;
            if (_lastObservedFirstTick != 0 && firstTick != _lastObservedFirstTick)
            {
                requiresFullSync = true;
            }
        }

        if (requiresFullSync)
        {
            _values.Clear();
            _lastAppliedCount = 0;
        }

        // Append only new points (avoid tearing down chart every tick)
        for (int i = _lastAppliedCount; i < currentCount; i++)
        {
            var p = Points[i];
            _values.Add(new ObservablePoint(p.X.ToOADate(), p.Y));
        }
        _lastAppliedCount = currentCount;

        // Keep a hard cap (optional; aligns with server cap)
        const int max = 2000;
        while (_values.Count > max) _values.RemoveAt(0);

        if (currentCount > 0)
        {
            _lastObservedFirstTick = Points[0].X.Ticks;
        }
        else
        {
            _lastObservedFirstTick = 0;
        }

        _lastKeyOrTitle = Title;

        xAxes[0].Name = string.IsNullOrWhiteSpace(Title) ? "Time" : Title!;
    }
}
