@rendermode InteractiveWebAssembly
@namespace EquipmentHubDemo.Components.Pages
@using Microsoft.AspNetCore.Components.Web
@using System
@using System.Collections.ObjectModel
@using System.Globalization
@using System.Threading
@using EquipmentHubDemo.Domain
@using LiveChartsCore
@using LiveChartsCore.Defaults
@using LiveChartsCore.SkiaSharpView
@using LiveChartsCore.SkiaSharpView.Blazor

@if (ShouldRenderChart)
{
    <div class="chart-island__surface">
        <CartesianChart Series="Series"
                        XAxes="xAxes"
                        YAxes="yAxes" />
    </div>
}
else
{
    <div data-testid="chart-placeholder" class="alert alert-info">
        Chart rendering is available in a WebAssembly-enabled environment only.
        To view live charts locally, run the WebAssembly host via <code>dotnet watch --project EquipmentHubDemo.Client</code>
        and open the site in a browser.
    </div>
}

@code {
    [Parameter] public IReadOnlyList<PointDto> Points { get; set; } = Array.Empty<PointDto>();
    /// <summary>
    /// Forces the component to render the chart even when <see cref="OperatingSystem.IsBrowser"/> returns <c>false</c>.
    /// Enable this when running the UI in a WebAssembly context but the runtime cannot yet detect the browser (e.g., during
    /// prerendering) to suppress the informational placeholder.
    /// </summary>
    [Parameter]
    public bool ForceEnableChartRendering { get; set; }
    [Parameter] public string? Title { get; set; }

    private static int _configuredFlag;

    private const string DefaultTimeAxisName = "Time (UTC)";

    private static readonly Func<double, string> TimeLabeler = value => DateTime.FromOADate(value)
        .ToString("HH:mm:ss", CultureInfo.InvariantCulture);

    private static readonly VerticalAxisMetadata DefaultVerticalAxis = new("Value", FormatWithTwoDecimals);

    private static readonly IReadOnlyDictionary<string, VerticalAxisMetadata> VerticalAxisByMetric =
        new Dictionary<string, VerticalAxisMetadata>(StringComparer.OrdinalIgnoreCase)
        {
            ["Temperature"] = new VerticalAxisMetadata("Temperature (°C)", FormatWithOneDecimal),
            ["Humidity"] = new VerticalAxisMetadata("Relative Humidity (%)", FormatWithOneDecimal),
            ["Power (240VAC)"] = new VerticalAxisMetadata("Power (240 VAC)", FormatWithTwoDecimals)
        };

    private readonly ObservableCollection<ObservablePoint> _values = new();
    private readonly Axis[] xAxes = { new Axis { Name = DefaultTimeAxisName, Labeler = TimeLabeler } };
    private readonly Axis[] yAxes = { new Axis { Name = DefaultVerticalAxis.Name, Labeler = DefaultVerticalAxis.Labeler } };
    private ISeries[] Series = Array.Empty<ISeries>();

    private string? _lastKeyOrTitle;
    private int _lastAppliedCount;
    private long _lastObservedFirstTick;

    private bool ShouldRenderChart => ForceEnableChartRendering || OperatingSystem.IsBrowser();

    protected override void OnInitialized()
    {
        if (Interlocked.Exchange(ref _configuredFlag, 1) == 0)
        {
            LiveCharts.Configure(cfg => cfg.AddSkiaSharp()); // must happen in WASM context
        }

        Series = new ISeries[]
        {
            new LineSeries<ObservablePoint>
            {
                Values = _values,
                GeometryFill = null,
                GeometryStroke = null,
                LineSmoothness = 0
            }
        };
    }

    protected override void OnParametersSet()
    {
        if (Points is null)
        {
            throw new ArgumentNullException(nameof(Points));
        }

        for (var i = 0; i < Points.Count; i++)
        {
            if (Points[i] is null)
            {
                throw new ArgumentException("Points cannot contain null entries.", nameof(Points));
            }
        }

        var requiresFullSync = false;

        if (_lastKeyOrTitle != Title)
        {
            requiresFullSync = true;
        }

        var currentCount = Points.Count;

        if (!requiresFullSync && currentCount < _lastAppliedCount)
        {
            requiresFullSync = true;
        }

        if (!requiresFullSync && _values.Count != currentCount)
        {
            requiresFullSync = true;
        }

        if (!requiresFullSync && currentCount > 0)
        {
            var firstTick = Points[0].X.Ticks;
            if (_lastObservedFirstTick != 0 && firstTick != _lastObservedFirstTick)
            {
                requiresFullSync = true;
            }
        }

        if (requiresFullSync)
        {
            _values.Clear();
            _lastAppliedCount = 0;
        }

        // Append only new points (avoid tearing down chart every tick)
        for (int i = _lastAppliedCount; i < currentCount; i++)
        {
            var p = Points[i];
            _values.Add(new ObservablePoint(p.X.ToOADate(), p.Y));
        }
        _lastAppliedCount = currentCount;

        // Keep a hard cap (optional; aligns with server cap)
        const int max = 2000;
        while (_values.Count > max) _values.RemoveAt(0);

        if (currentCount > 0)
        {
            _lastObservedFirstTick = Points[0].X.Ticks;
        }
        else
        {
            _lastObservedFirstTick = 0;
        }

        ApplyAxisMetadata(Title);

        _lastKeyOrTitle = Title;
    }

    private void ApplyAxisMetadata(string? rawKey)
    {
        xAxes[0].Labeler = TimeLabeler;

        if (!string.IsNullOrWhiteSpace(rawKey) && MeasureKey.TryParse(rawKey, out var parsedKey))
        {
            xAxes[0].Name = string.IsNullOrWhiteSpace(parsedKey.InstrumentId)
                ? DefaultTimeAxisName
                : $"{parsedKey.InstrumentId} Time (UTC)";

            var vertical = ResolveVerticalAxis(parsedKey.Metric);
            yAxes[0].Name = vertical.Name;
            yAxes[0].Labeler = vertical.Labeler;
            return;
        }

        xAxes[0].Name = DefaultTimeAxisName;
        var fallback = ResolveVerticalAxis(null);
        yAxes[0].Name = fallback.Name;
        yAxes[0].Labeler = fallback.Labeler;
    }

    private static VerticalAxisMetadata ResolveVerticalAxis(string? metric)
    {
        if (!string.IsNullOrWhiteSpace(metric) && VerticalAxisByMetric.TryGetValue(metric, out var metadata))
        {
            return metadata;
        }

        if (!string.IsNullOrWhiteSpace(metric))
        {
            return new VerticalAxisMetadata(metric, DefaultVerticalAxis.Labeler);
        }

        return DefaultVerticalAxis;
    }

    private static string FormatWithTwoDecimals(double value)
        => value.ToString("0.##", CultureInfo.InvariantCulture);

    private static string FormatWithOneDecimal(double value)
        => value.ToString("0.#", CultureInfo.InvariantCulture);

    private sealed record VerticalAxisMetadata(string Name, Func<double, string> Labeler);
}
