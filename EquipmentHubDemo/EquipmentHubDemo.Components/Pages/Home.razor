@page "/"
@using Microsoft.AspNetCore.Components.Web
@using System.Linq
@using System.Text
@implements IAsyncDisposable
@rendermode InteractiveWebAssembly
@namespace EquipmentHubDemo.Components.Pages

@inject ILiveMeasurementClient Measurements

<h3>Live Measurements</h3>
<p class="text-muted">Agent → Broker → Filter/Store → Live cache → (WASM UI)</p>

@if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">@error</div>
}

<div class="d-flex flex-column flex-lg-row gap-3 align-items-lg-center">
    <div class="flex-grow-1">
        <div class="d-flex flex-wrap align-items-center gap-3">
            @foreach (var key in keys)
            {
                var checkboxId = CreateCheckboxId(key);
                <div class="form-check form-check-inline">
                    <input class="form-check-input"
                           type="checkbox"
                           id="@checkboxId"
                           checked="@IsSelected(key)"
                           @onchange="async e => await OnKeyToggledAsync(key, e)" />
                    <label class="form-check-label" for="@checkboxId">@key</label>
                </div>
            }
        </div>
    </div>

    <div class="d-flex align-items-center gap-2">
        <button class="btn btn-sm btn-primary" @onclick="ToggleAsync">@((running ? "Pause" : "Run"))</button>
        <span class="badge bg-primary text-wrap">Measurements received: @TotalReceived</span>
        <span class="text-muted small">Active buffer: @ActiveBufferCount</span>
    </div>
</div>

@if (!string.IsNullOrEmpty(selectionWarning))
{
    <div class="alert alert-warning mt-2" role="alert">@selectionWarning</div>
}

<div class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mt-2">
    @foreach (var stream in GetActiveStreams())
    {
        <div class="col">
            <div class="card h-100">
                <div class="card-body">
                    <h6 class="card-title text-muted">@stream.Key</h6>
                    <ChartIsland Points="stream.Points"
                                 Title="stream.Key" />
                </div>
            </div>
        </div>
    }
</div>

@code {
    private string? error;

    private const int MaxChartsDisplayed = 3;

    private List<string> keys = new();
    private IReadOnlyList<string> _selectedKeys = Array.Empty<string>();
    private bool running = true;

    private CancellationTokenSource? _cts;
    private Task? _pollingTask;
    private CancellationTokenSource? _keyRefreshCts;
    private Task? _keyRefreshTask;

    private readonly Dictionary<string, ChartStream> _chartStreams = new(StringComparer.Ordinal);

    private string? selectionWarning;

    private long TotalReceived => _chartStreams.Values.Sum(s => s.TotalReceived);
    private int ActiveBufferCount => _selectedKeys.Sum(key => _chartStreams.TryGetValue(key, out var stream) ? stream.Points.Count : 0);

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await TryLoadKeysAsync(initialLoad: true);
        }
        catch (Exception ex)
        {
            error = "Init failed: " + ex.Message;
        }

        EnsureKeyRefreshLoop();
    }

    private async Task ToggleAsync()
    {
        running = !running;
        if (running)
        {
            await StartPollingAsync();
        }
        else
        {
            await StopPollingAsync();
        }
    }

    private async Task StartPollingAsync()
    {
        await StopPollingAsync();

        if (_selectedKeys.Count == 0)
        {
            return;
        }

        ResetStreams();

        _cts = new CancellationTokenSource();
        _pollingTask = PollLoopAsync(_cts.Token);
        await InvokeAsync(StateHasChanged);
    }

    private async Task StopPollingAsync()
    {
        if (_cts is null)
        {
            return;
        }

        _cts.Cancel();
        var toAwait = _pollingTask;
        _pollingTask = null;

        _cts.Dispose();
        _cts = null;

        if (toAwait is not null)
        {
            try
            {
                await toAwait;
            }
            catch (OperationCanceledException)
            {
                // expected when stopping
            }
        }
    }

    private async Task PollLoopAsync(CancellationToken ct)
    {
        try
        {
            using var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(250));
            while (await timer.WaitForNextTickAsync(ct))
            {
                if (!running)
                {
                    continue;
                }

                try
                {
                    var keysSnapshot = _selectedKeys;
                    if (keysSnapshot.Count == 0)
                    {
                        continue;
                    }

                    var hadUpdates = false;

                    foreach (var key in keysSnapshot)
                    {
                        if (!_chartStreams.TryGetValue(key, out var stream))
                        {
                            continue;
                        }

                        var batch = await Measurements.GetMeasurementsAsync(key, stream.SinceTicks, ct);

                        if (batch is null || batch.Count == 0)
                        {
                            continue;
                        }

                        if (stream.Apply(batch))
                        {
                            hadUpdates = true;
                        }
                    }

                    if (hadUpdates)
                    {
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    error ??= "Polling error: " + ex.Message;
                }
            }
        }
        catch (OperationCanceledException)
        {
            // loop cancelled -> exit silently
        }
    }

    public async ValueTask DisposeAsync()
    {
        await StopPollingAsync();
        await StopKeyRefreshLoopAsync();
    }

    private async Task<bool> TryLoadKeysAsync(bool initialLoad)
    {
        var latestKeys = await Measurements.GetAvailableKeysAsync();
        var latest = latestKeys is null ? new List<string>() : new List<string>(latestKeys);

        keys = latest;
        if (keys.Count == 0)
        {
            await StopPollingAsync();
            error = "Waiting for live data…";
            _selectedKeys = Array.Empty<string>();
            _chartStreams.Clear();
            StateHasChanged();
            return false;
        }

        error = null;

        UpdateSelectionAfterKeyRefresh(ensureSelection: initialLoad);

        if (running)
        {
            if (initialLoad)
            {
                await StartPollingAsync();
            }
        }
        else
        {
            StateHasChanged();
        }

        return true;
    }

    private void EnsureKeyRefreshLoop()
    {
        if (_keyRefreshTask is not null)
        {
            return;
        }

        _keyRefreshCts = new CancellationTokenSource();
        _keyRefreshTask = RefreshKeysLoopAsync(_keyRefreshCts.Token);
    }

    private async Task RefreshKeysLoopAsync(CancellationToken ct)
    {
        var delay = TimeSpan.FromSeconds(2);
        var firstIteration = true;

        try
        {
            while (!ct.IsCancellationRequested)
            {
                if (!firstIteration)
                {
                    await Task.Delay(delay, ct);
                }
                firstIteration = false;

                List<string> latest;
                try
                {
                    var refreshedKeys = await Measurements.GetAvailableKeysAsync(ct);
                    latest = refreshedKeys is null ? new List<string>() : new List<string>(refreshedKeys);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    await InvokeAsync(() =>
                    {
                        error = "Key refresh failed: " + ex.Message;
                        StateHasChanged();
                    });
                    continue;
                }

                await InvokeAsync(async () =>
                {
                    var hadKeysBefore = keys.Count > 0;

                    keys = latest;

                    if (keys.Count == 0)
                    {
                        if (hadKeysBefore)
                        {
                            await StopPollingAsync();
                        }

                        error = "Waiting for live data…";
                        _selectedKeys = Array.Empty<string>();
                        _chartStreams.Clear();
                        StateHasChanged();
                        return;
                    }

                    error = null;

                    var selectionChanged = UpdateSelectionAfterKeyRefresh(ensureSelection: !hadKeysBefore);

                    if (running && (selectionChanged || !hadKeysBefore))
                    {
                        await StartPollingAsync();
                    }
                    else
                    {
                        StateHasChanged();
                    }
                });
            }
        }
        catch (OperationCanceledException)
        {
            // loop cancelled -> exit silently
        }
        finally
        {
            await InvokeAsync(() =>
            {
                _keyRefreshTask = null;
                _keyRefreshCts?.Dispose();
                _keyRefreshCts = null;
            });
        }
    }

    private async Task StopKeyRefreshLoopAsync()
    {
        if (_keyRefreshTask is null)
        {
            return;
        }

        try
        {
            _keyRefreshCts?.Cancel();
            await _keyRefreshTask;
        }
        catch (OperationCanceledException)
        {
            // expected on cancellation
        }
        finally
        {
            _keyRefreshCts?.Dispose();
            _keyRefreshCts = null;
            _keyRefreshTask = null;
        }
    }

    private async Task OnKeyToggledAsync(string key, ChangeEventArgs e)
    {
        var isChecked = e.Value is bool boolean && boolean;

        if (isChecked)
        {
            if (_selectedKeys.Contains(key, StringComparer.Ordinal))
            {
                return;
            }

            if (_selectedKeys.Count >= MaxChartsDisplayed)
            {
                selectionWarning = $"You can display up to {MaxChartsDisplayed} charts at a time.";
                await InvokeAsync(StateHasChanged);
                return;
            }

            selectionWarning = null;
            _selectedKeys = _selectedKeys.Concat(new[] { key }).ToList();
        }
        else
        {
            if (!_selectedKeys.Contains(key, StringComparer.Ordinal))
            {
                return;
            }

            selectionWarning = null;
            _selectedKeys = _selectedKeys.Where(k => !string.Equals(k, key, StringComparison.Ordinal)).ToList();
        }

        EnsureStreamsForSelection();

        if (running)
        {
            await StartPollingAsync();
        }
        else
        {
            StateHasChanged();
        }
    }

    private IEnumerable<ChartStream> GetActiveStreams()
    {
        foreach (var key in _selectedKeys)
        {
            if (_chartStreams.TryGetValue(key, out var stream))
            {
                yield return stream;
            }
        }
    }

    private void ResetStreams()
    {
        foreach (var key in _selectedKeys)
        {
            if (_chartStreams.TryGetValue(key, out var stream))
            {
                stream.Reset();
            }
            else
            {
                _chartStreams[key] = new ChartStream(key);
            }
        }

        var keysToRemove = _chartStreams.Keys.Where(key => !_selectedKeys.Contains(key, StringComparer.Ordinal)).ToList();
        foreach (var key in keysToRemove)
        {
            _chartStreams.Remove(key);
        }
    }

    private void EnsureStreamsForSelection()
    {
        foreach (var key in _selectedKeys)
        {
            if (!_chartStreams.ContainsKey(key))
            {
                _chartStreams[key] = new ChartStream(key);
            }
        }

        var keysToRemove = _chartStreams.Keys.Where(key => !_selectedKeys.Contains(key, StringComparer.Ordinal)).ToList();
        foreach (var key in keysToRemove)
        {
            _chartStreams.Remove(key);
        }
    }

    private bool UpdateSelectionAfterKeyRefresh(bool ensureSelection)
    {
        var sanitizedSelection = _selectedKeys
            .Where(key => keys.Contains(key, StringComparer.Ordinal))
            .ToList();

        var selectionChanged = sanitizedSelection.Count != _selectedKeys.Count
            || !_selectedKeys.SequenceEqual(sanitizedSelection, StringComparer.Ordinal);

        if (ensureSelection && sanitizedSelection.Count == 0 && keys.Count > 0)
        {
            sanitizedSelection = keys.Take(MaxChartsDisplayed).ToList();
            selectionChanged = true;
        }

        if (selectionChanged)
        {
            selectionWarning = null;
        }

        _selectedKeys = sanitizedSelection;

        EnsureStreamsForSelection();

        return selectionChanged;
    }

    private static string CreateCheckboxId(string key)
    {
        if (string.IsNullOrWhiteSpace(key))
        {
            return "key-unknown";
        }

        var builder = new StringBuilder("key-");
        foreach (var ch in key)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? char.ToLowerInvariant(ch) : '-');
        }

        return builder.ToString();
    }

    private bool IsSelected(string key)
        => _selectedKeys.Contains(key, StringComparer.Ordinal);

    private sealed class ChartStream
    {
        public ChartStream(string key)
        {
            Key = key ?? throw new ArgumentNullException(nameof(key));
        }

        public string Key { get; }

        public List<PointDto> Points { get; } = new();

        public long SinceTicks { get; private set; }

        public long TotalReceived { get; private set; }

        public bool Apply(IReadOnlyList<PointDto> batch)
        {
            if (batch is null)
            {
                throw new ArgumentNullException(nameof(batch));
            }

            var newPoints = 0;
            foreach (var point in batch)
            {
                if (point is null)
                {
                    throw new ArgumentException("Batch cannot contain null points.", nameof(batch));
                }

                Points.Add(point);
                SinceTicks = Math.Max(SinceTicks, point.X.Ticks);
                newPoints++;
            }

            const int max = 2000;
            if (Points.Count > max)
            {
                var excess = Points.Count - max;
                Points.RemoveRange(0, excess);
            }

            if (newPoints == 0)
            {
                return false;
            }

            TotalReceived += newPoints;
            return true;
        }

        public void Reset()
        {
            Points.Clear();
            SinceTicks = 0;
            TotalReceived = 0;
        }
    }
}
